Iqvoc.default_rdf_namespace_helper_methods.each do |meth|
  document.namespaces(self.send(meth))
end

document << @concept.build_rdf_subject(document, controller) do |concept|
  @concept.labelings.each do |labeling|
    labeling.build_rdf(document, concept)
  end

  @concept.relations.each do |relation|
    relation.build_rdf(document, concept)
  end

  @concept.notes.each do |note|
    note.build_rdf(document, concept)
  end

  Iqvoc::Concept.additional_association_class_names.keys.each do |class_name|
    @concept.send(class_name.to_relation_name).each do |additional_object|
      additional_object.build_rdf(document, concept)
    end
  end

=begin
  %w(historyNotes scopeNotes editorialNotes examples definitions).each do |name|
    concept.Skos::build_predicate(name.singularize, *@concept.send(name.underscore).map{|note| IqRdf::Literal.new(note, note.language) }) unless @concept.send(name.underscore).empty?
  end

  %w(exportNote changeNote sourceNote usageNote).each do |relation|
    relation_name = 'umt_' << relation.underscore.pluralize
    @concept.send(relation_name).each do |element|
      if element.annotations.blank?
        concept.Umt::build_predicate(relation, IqRdf::Literal.new(element, element.language))
      else
        concept.Umt::build_predicate(relation) do |blank_node|
          element.annotations.each do |na|
            ns, id = na.identifier.split(':')
            blank_node.send(ns.camelize).build_predicate(id, IqRdf::PlainTurtleLiteral.new(na.value))
          end
        end
      end
    end
  end
  %w(closeMatch broaderMatch narrowerMatch exactMatch).each do |relation|
    concept.Skos::build_predicate(relation, *@concept.send(relation.pluralize.underscore).map{|match| URI.parse(match.value)}) unless @concept.send(relation.pluralize.underscore).empty?
  end
  concept.Skos::build_predicate("classified", *@concept.classifiers.map{|classifier| classifier.notation}) unless @concept.classifiers.empty?
  concept.Skos::build_predicate("status", @concept.status)
=end
end